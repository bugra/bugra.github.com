<!DOCTYPE html>
<head>
  <meta charset="utf-8"/>
  <title>PigPen, Hadoop, Pig, Clojure and All That &mdash; Machine Learning and Management</title>

  <link type="text/css" rel="stylesheet" href="/static/sdist/ff9ec00429d34a18995915040b9b5bf9.css">

  <script type="text/javascript" src="/static/sdist/aa45836fe5eaf91e9c964fd639fa3c1f.js"></script>

  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"type="text/javascript"></script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    });
  </script>

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel='shortcut icon' href="/static/favicon.ico" type='image/x-icon'/>
  <style type="text/css">
   img { mix-blend-mode: multiply; }
  </style>
  <meta property="og:author" content="Bugra Akyildiz" />
  <meta property="og:title" content="PigPen, Hadoop, Pig, Clojure and All That" />
  <meta property="og:type" content="website" />
  <meta property="og:description" content="" />
  <meta property="og:url" content="https://bugra.github.io/posts/2014/7/9/pig-pen-or-clojure-for-big-data/" />
  <meta property="og:image" content="/static/img/athena.png" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="PigPen, Hadoop, Pig, Clojure and All That" />
  <meta name="twitter:description" content="" />
  <meta name="twitter:url" content="https://bugra.github.io/posts/2014/7/9/pig-pen-or-clojure-for-big-data/" />
  <meta name="twitter:image" content="/static/img/athena.png" />
</head>
<body>
    <div class="marginnote">
        <div id="logo"><a href="/" class="at"></a></div>
    </div>
  <div class="thearticle">
  
  <article>
  
    <h1>PigPen, Hadoop, Pig, Clojure and All That</h1>
    <p id="blog-p"><span id="blogdesc" class="marginnote">
    other things ;) <br><br>
    <a href="/">home</a> ·
    
      <a href="/about/">
        about</a> ·
    
    <a href="/feed.atom">subscribe</a></span></p>

    <subtitle class="sub-date">July 09, 2014 · <span
    style="font-size: 1.6rem;"><a style="border-bottom-width: 0px !important;"
    href="https://bugra.github.io/posts/2014/7/9/pig-pen-or-clojure-for-big-data/">&infin;</a></span></subtitle>

    <!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Untitled</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<figure>
<img src="http://i.imgur.com/dJ5nhHd.jpg" title="Big Data vs me" alt="" /><figcaption>Big Data vs me</figcaption>
</figure>
<p>My humble contribution to <a href="http://bigdatapix.tumblr.com/">ridiculous images on big data</a>.</p>
<p>This post is about <a href="https://github.com/Netflix/PigPen">PigPen</a>, a library that Netflix open sourced in the beginning of this year. Yet, in order to introduce the library, I covered some background namely Hadoop, Pig and Clojure which PigPen builds on top of those. If you want to jump right away to my rant on PigPen right away, scroll a bit.</p>
<h3 id="hadoop">Hadoop</h3>
<p>Hadoop (a.k.a distributed data processing framework for counting words) built on top of idea of map-reduce, famous Google <a href="http://static.googleusercontent.com/media/research.google.com/en/us/archive/mapreduce-osdi04.pdf">paper</a> not only changed how we process data(it is a data processing framework after all) but also create new perspectives on how we might think about data, what type of opportunities that it could provide, how can we use the data we collect. The latter one, the implicit role on collected data usage has a quite profound effect on different type of skills(data wrangling,data analysis, scraping and so on), job types(suddenly you started to hear data engineers, data scientists ..) and also company types(data companies that just collect data and provide in a nice interface possibly through an API, data analytics company that creates nice visualizations and interfaces to interact with and learn from the data, big data consulting companies that provide consulting for big data technologies and so on). Do not get me wrong, I am not saying Hadoop is the <em>only</em> cause for this change but it plays a strong role as it contributed to the change on how we might perceive the data.</p>
<p>Hadoop adoption was great at first thanks to “big data” and its tireless marketers, early adopters, media that repeatedly overloads the phrase, or maybe it was all because developers who want to learn another new cool technology. I am not sure at this point(I bet on “big data” gods, though). After some time, some researchers found out that <a href="http://research.microsoft.com/pubs/163083/hotcbp12%20final.pdf">Noboy got ever fired for using Hadoop on a cluster</a> which is a skeptical view of Hadoop and tries to advocate the usage of memory as it becomes cheaper and cheaper. If you are following big data space, they were almost suggesting using Spark. However, even if the Hadoop popularity suffered a little bit, its adoption did not seem to decrease over time. People who have big data, they still try to use Hadoop for their data processing system.</p>
<p>However, one thing became clear after Hadoop became mainstream that nobody really wanted to write vanilla map-reduce programs. Not only they were very low level but also you need to write a lot of boiler plate for the things that are very common in a data processing systems. They wanted more abstraction than what Hadoop provides. They wanted other language interfaces, too. Because writing Java has been one of the most fulfilling development experience said an experienced nobody developer.(By the way, Java is a fine programming language if not great if you ask me.)</p>
<h3 id="abstractions-abstractions-and-more-abstractions">Abstractions, Abstractions, and more Abstractions</h3>
<p>We need moar abstractions said one junior developer who spent two days to write a buggy combiner. Not only more abstractions, we need functional programming language interfaces said another junior developer who loves Haskell. We need better workflows for common tasks said another developer. We already know SQL and hate it, why learning another new domain specific language and hate it said a senior developer. Later this developer would happily announce that he hates Hive as much as he hates SQL.</p>
<h3 id="software-abstraction-projects-on-top-of-hadoop">Software Abstraction Projects on Top of Hadoop</h3>
<p>Software abstraction projects then developed in order to satisfy some of these needs. The abstraction does not refer mere software abstractions and the concepts that Hadoop provides but also it refers how common tasks(counting words) are abstracted in a way that minimal boilerplate code requires.(if a project requires one-liner for counting words, then it wins.)</p>
<p>Pig and Hive came into the play first. Pig provides a nice language and data processing flow for data processing tasks through User Defined Functions(UDFs). I write a little bit about on Pig in <a href="http://bugra.github.io/work/notes/2014-02-08/pig-advantages-and-disadvantages/">here</a> if you want to learn more.</p>
<p>Hive’s adoption is surprisingly good, whose query language is very similar to SQL. The data analysts that write SQL queries start to write HiveQL queries to analyze the data so the effort that requires for another new language became minimal. Instead of learning a new language, it may make more sense for the companies that want to minimize their efforts and want to maximize the outcome of their employees.</p>
<p>If I compare these two, I would much prefer Pig just because its language is better than SQL. In general, I strongly believe that declarative style is not very good how you might want to interact with your data. Pig’s transformation based approach, especially the transformations as a first class citizen approach is very good in this regard.</p>
<h3 id="cascading">Cascading</h3>
<p>What if you do not want to learn any new technology, but you will write code that you write everyday, but magically it will process big data out of the box. Cascading is a project that wants to abstract whole map-reduce flow flow and creates the pipeline for you out of the box. Cascading is the framework name and it is for Java but it has quite a lot of interfaces for different languages as well, the most prominent is Scalding for Scala. It has also Clojure interface which is Cascalog and PigPen could be considered as a competitor for Cascalog.</p>
<p>It has a bunch of cool projects on top of it, I will mention in here briefly, but if you are interested in check it on their website. Especially, Pattern seems quite nice for Machine Learning models as it supports PMML and you could dploy your models tested on smaller data on big data seamlessly.</p>
<h3 id="pattern">Pattern</h3>
<p>It also has Pattern which combines Predictive Model Markup Language(PMML) with Cascading to make the Machine learning deployment much easier. This is very nice for a number of reasons but most important reason is that if you evaluate your machine learning algorithm for small dataset, then to apply the model into the production is quite seamless.</p>
<h3 id="lingual">Lingual</h3>
<p>SQL for Cascading would be a good term to explain what Lingual is. It provides a SQL interface for Hadoop, which makes it easier to interact the data. This also aims to interoperability as you could make SQL queries for big data in the same way you do in a much smaller scale. If you are using any third party application on top of your data, you could also connect through this interface as your big data supports for big data as well.</p>
<h3 id="driven">Driven</h3>
<p>It tries to visualize your data processing system on top of Cascading; dependencies and other components. Similar to <a href="https://github.com/Netflix/Lipstick">Lipstick</a></p>
<h3 id="netflix-approach">Netflix approach</h3>
<p>Instead of Cascading, Netlix seems to choose Pig as a data processing backbone for processing data. Therefore, they seem to build their stack on top of Pig. They put up Lipstick previously which is very similar to Driven. Now, they are putting PigPen which is very similar to Cascalog in spirit. Main(maybe not only) difference is the underlying data processing environments.</p>
<p>Cascading generally differs from Pig and Hive where you do not want to write quick-dirty scripts but rather a production environment which you could deploy. Otherwise, if you want to do data ad-hoc data analysis Pig or even Hive might give better solutions than what Cascading provides. Even for this reason, PigPen is a nice competitor for Cascalog in Clojure league.</p>
<blockquote>
<p>There are also Scoobi, Scrunch and Spark that you may want to consider for your needs. Especially, if you have data that could be fit a good computer, Spark may be more suitable.</p>
</blockquote>
<h3 id="pig">Pig</h3>
<h4 id="twitter">Twitter</h4>
<p><a href="http://www.umiacs.umd.edu/~jimmylin/publications/Lin_Kolcz_SIGMOD2012.pdf">Large Scale Machine Learning at Twitter paper</a> gives a good overview why Pig is good for Machine learning and data processing in general.(If you are interested in the paper, its presentation is <a href="http://videolectures.net/eswc2012_kolcz_twitter/">here</a>) It basically says that Pig is the backbone of the processing framework where you could use mighty Python libraries for scientific computing, data processing and machine learning. As you have a general domain programming language that you could depend on via User Defined Functions(UDF’s), you could pretty much process you data however you want independent from the big data as the platform built on Pig already handles query planning as well as Hadoop aspects. Only job is to write UDF’s and combine the processing steps in the Pig. Seems quite straightforward. Netflix also seems to adopt this approach and I find particularly very good for machine learning and data processing in general. I also wrote my rants on these issues as well; <a href="http://bugra.github.io/work/notes/2014-02-08/pig-advantages-and-disadvantages/">previously on Pig</a> and on the <a href="http://bugra.github.io/work/notes/2014-02-09/pig-not-so-foreign-language-paper-notes/">original paper</a> that explains the rationale behind Pig and some of its advantages and disadvantages over vanilla map-reduce.</p>
<p>I really like Pig and its approach in data processing as I wrote previously. However, big data is a field that sees a surprisingly good adoption and growing community. Therefore, it is not unexpected that people actually try to push the field quite a lot, trying to come up better solutions for data processing problems. Pig is still being developed and see improvements, features(<code>cube</code> and <code>roll</code> functions) and bug fixes, which is great but what about its shortcomings?</p>
<h3 id="disadvantages-of-pig">Disadvantages of Pig</h3>
<ul>
<li>Even very simple tasks(i/o) requires a lot of boilerplate code. Importing jar files, registering macros, setting the parameters and so on.</li>
<li>You need to maintain two and sometimes three different codebase(Java, Pig) or if you are using Jython for UDF’s, add Python as well.</li>
<li>All of the scripts that are wrapped in Pig is specific to processing jobs. Therefore, even though UDF’s are reusable across different jobs, the component of jobs cannot be reusable. (Macros provide a limited mechanism to do so to be fair, though).</li>
<li>Due to partially above reason, programs becomes scripts rather than full fledge production workfklows.</li>
</ul>
<h2 id="functional-programming">Functional Programming</h2>
<p>Functional programming is a paradigm where it puts an emphasis on functions which are pure and evaluated as mathematical functions. That means for same input, they always yield same result. This is one of the reason why it is popular, as the functions do not have side effects, this leads cleaner, readable and more bug-free programs. There are a lot of functional programming languages: Common Lisp, Clojure, Erlang, Haskell, Ocaml, F# to name a few. However, these languages also differ quite drastically as some of the languages give more importance to types(Haskell) whereas some others adopt more dynamic approach(Clojure). Some programming languages are not pure functional programming languages but provide various structures and methods to enable developers to write functional programming style: Scala, Python and C# could be examples of this category.</p>
<h3 id="clojure">Clojure</h3>
<p>Clojure is a modern a dialect of List programming language specifically targeted to Java Virtual Machine(JVM). Rich Hikey who is the inventor and main developer of Clojure explains the rationale why there is a need for clojure in <a href="http://clojure.org/rationale">here</a> which I would like to replicate some of the core aspects in here as well:</p>
<ol type="1">
<li><strong>Functional Programming Language</strong></li>
<li><strong>Designed for Concurrency</strong></li>
<li>Immutable data structures + first-class functions</li>
<li>Dynamic emphasis instead of strongly types(unlike Haskell)</li>
<li>JVM is good platform and Java community and libraries could be useful.</li>
<li>Write Java wherever you have to, extend it with Clojure wherever you can.</li>
<li>Object oriented programming language is overrated.</li>
<li>Inheritance is not only way to do polymorphism.</li>
</ol>
<p>Also, some of the design principles and features are listed in <a href="http://clojure.org/features">here</a>.</p>
<h3 id="syntax">Syntax</h3>
<p>Since it is a dialectic of Lisp, and the language is itself homoiconic, the syntax and also the layout of the programs tend to very similar. Most people hate parentheses but coming from Python, even if it is not readable as Python, it is much more pleasant than say Java or Perl where they exploit a lot of different non-characters to form their syntax. This makes it also learn the syntax of Clojure piece of cake.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb1-1"><a href="#cb1-1"></a>(<span class="bu">def</span><span class="fu"> fibonacci</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>    (<span class="kw">lazy-cat</span> [<span class="dv">0</span> <span class="dv">1</span>] (<span class="kw">map</span> <span class="kw">+</span> (<span class="kw">rest</span> fibonacci) fibonacci)))</span>
<span id="cb1-3"><a href="#cb1-3"></a>(<span class="kw">take</span> <span class="dv">10</span> fibonacci) <span class="co">; Get first 10 fibonacci numbers</span></span></code></pre></div>
<p>S expressions are good but they become quite hard to unread if you are doing step by step data processing. Consider the next example;</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb2-1"><a href="#cb2-1"></a>(<span class="kw">map</span> <span class="kw">str</span> (<span class="kw">map</span> <span class="kw">inc</span> (<span class="kw">filter</span> <span class="kw">pos?</span> (<span class="kw">range</span> <span class="dv">-5</span> <span class="dv">6</span>))))</span></code></pre></div>
<p>We are getting a vector, filter out the negative values, increment the rest of the numbers and return string representation. However, it is hard to read. Especially, if clojure would be useful for data processing, this becomes quite cumbersome, as we want to abstract each step(i/o, extract-tranformation-load(etl), preprocessing, processing). Clojure provides threading macro mechanism to handle this type of sequence processing.</p>
<h3 id="macros-to-rescue">Macros to rescue</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb3-1"><a href="#cb3-1"></a> (<span class="kw">-&gt;&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>   (<span class="kw">range</span> <span class="dv">-5</span> <span class="dv">6</span>)</span>
<span id="cb3-3"><a href="#cb3-3"></a>   (<span class="kw">filter</span> <span class="kw">pos?</span>)</span>
<span id="cb3-4"><a href="#cb3-4"></a>   (<span class="kw">map</span> <span class="kw">inc</span>)</span>
<span id="cb3-5"><a href="#cb3-5"></a>   (<span class="kw">map</span> <span class="kw">str</span>))</span></code></pre></div>
<p>The same expression as previous, yet much readable. Since it is also reversed order, you could follow the execution order where in the previous representation you need to go from the inner expressions to the outer expressions. What would be equivalent of this processing in Python.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a>[<span class="bu">str</span>(ii<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> ii <span class="kw">in</span> <span class="bu">range</span>(<span class="op">-</span><span class="dv">5</span>, <span class="dv">6</span>) <span class="cf">if</span> ii <span class="op">&gt;=</span> <span class="dv">0</span>]</span></code></pre></div>
<p>Definitely, very readable but not perfect(Pythonic, though). Python supports functional programming to some degree, so we could use functional programming approach to tackle the same problem.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a><span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">str</span>, <span class="bu">map</span>(<span class="kw">lambda</span> k: k<span class="op">+</span><span class="dv">1</span>, <span class="bu">filter</span>(<span class="kw">lambda</span> k: k <span class="op">&gt;=</span> <span class="dv">0</span>, <span class="bu">range</span>(<span class="op">-</span><span class="dv">5</span>, <span class="dv">6</span>)))))</span></code></pre></div>
<p>We could improve the <code>lambda</code> expressions if we abstract into functions similar to clojure:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a><span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">str</span>, <span class="bu">map</span>(inc_, <span class="bu">filter</span>(pos, <span class="bu">range</span>(<span class="op">-</span><span class="dv">5</span>,<span class="dv">6</span>)))))</span></code></pre></div>
<p>More readable and improved, yet it is not Pythonic and still suffers reading from the inner expressions to outer expressions, hard to read:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a>pos_vals <span class="op">=</span> <span class="bu">filter</span>(pos, <span class="bu">range</span>(<span class="op">-</span><span class="dv">5</span>, <span class="dv">6</span>))</span>
<span id="cb7-2"><a href="#cb7-2"></a>inc_vals <span class="op">=</span> <span class="bu">map</span>(inc_, pos_vals)</span>
<span id="cb7-3"><a href="#cb7-3"></a>str_vals <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">str</span>, inc_vals))</span></code></pre></div>
<p>Generally, Python programmers write programs like these, use intermediate variables, as it is much easier to debug, also much easier to read. One-liners are cool but not readable nor maintainable. I choose this example because of both syntax similarities as well as keyword names’ similarities of Python and Clojure for this particular example.</p>
<p>Clojure with threading macro provides a great mechanism, other languages Javascript provides also a method chaining mechanism where you want to process data by cascading methods in a readable fashion. Scalding (Scala implementation of Cascading) also provides a very similar syntax and feeling, if you are familiar, check that out as well.</p>
<h2 id="pigpen">PigPen</h2>
<p><img src="http://i.imgur.com/mhil2yS.png%20PigPen%20Logo" alt="PigPen" /> PigPen combines the Clojure awesomeness namely functional programming, Lisp and JVM on top of Pig. This is quite awesome for a number of reasons:</p>
<ol type="1">
<li>You write clojure, no Pig at all. I know I said Pig is great language but with either Python or Java UDF’s, it is harder to maintain two codebase rather than one. And for data processing, however I like transformations first approach of Pig, I much prefer Clojure’s functional programming style to deal with data.</li>
<li>You get to use Clojure wherever you want in the processing seamlessly. Either that could be a preprocessing step or it could be something that you used UDF’s for, it does not matter, use Clojure. Therefore, you are not limited to Pig functions at all. Similar to UDF’s, except you are writing the UDF’s in the overall flow.</li>
<li>Clojure has not been around for a long time and its library support is not great. Therefore, the libraries that you want to use may not exist in clojure. However, do not despair, JVM to rescue! If there is a library in Java, which does not exist for Clojure, import the Java library inside of Clojure. Clojure core exploits a number of Java primitive functions like <code>Integer/valueOf</code> to get integer representation of a string. JVM works for Clojure, exploit it wherever you can without paying the burden of writing Java.</li>
<li>You could write composable programs since Clojure provides much nicer abstractions than Pig. You could write general purpose functions and reuse all the time, e.g loading data:</li>
</ol>
<div class="sourceCode" id="cb8"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb8-1"><a href="#cb8-1"></a>(<span class="bu">defn</span><span class="fu"> input-data </span>[input-path]</span>
<span id="cb8-2"><a href="#cb8-2"></a>  (pig/load-tsv input-path))</span></code></pre></div>
<ol start="5" type="1">
<li>Pig becomes a library that you could just import in the dependencies(with Leiningen) this is straightforward. (If you are using Jython for Python UDF’s, jars, dependencies become a nightmare after some time.) To be able to use it, only the following lines are needed in <code>project.clj</code>:</li>
</ol>
<div class="sourceCode" id="cb9"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb9-1"><a href="#cb9-1"></a><span class="at">:dependencies</span> [[org.clojure/clojure “<span class="dv">1</span>.<span class="fl">6.0</span>”]</span>
<span id="cb9-2"><a href="#cb9-2"></a>               [com.netflix.pigpen/pigpen “<span class="dv">0</span>.<span class="fl">2.6</span>”]]</span></code></pre></div>
<p>Remaining is handled by mighty <strong>Leiningen</strong> for you.</p>
<blockquote>
<p>It just works. Just works.</p>
</blockquote>
<p>Yes, there are no jar files, no external binary files. Only one line states PigPen dependency and that is it.</p>
<ol start="6" type="1">
<li>Pig is actually another library that you import and you could use Pig functions wherever you need to. Pig functions could be called after importing PigPen:</li>
</ol>
<div class="sourceCode" id="cb10"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb10-1"><a href="#cb10-1"></a>(<span class="kw">require</span> ‘[pigpen.core <span class="at">:as</span> pig])</span></code></pre></div>
<p>Pig functions are good old Pig functions with very-to-no differences between actual Pig functions. 7. Scripts are not specific to jobs, they are regular functions that could use other functions. See the example:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb11-1"><a href="#cb11-1"></a>(<span class="bu">defn</span><span class="fu"> process-data </span>[input-path output-path]</span>
<span id="cb11-2"><a href="#cb11-2"></a>     (input-data input-path)</span>
<span id="cb11-3"><a href="#cb11-3"></a>     (process)</span>
<span id="cb11-4"><a href="#cb11-4"></a>     (pig/dump)</span>
<span id="cb11-5"><a href="#cb11-5"></a>     (spit output-path)))</span></code></pre></div>
<p>where <code>process</code> is your awesome logic that includes different transformations and does the heavy processing to your data. Reuse in this example should be obvious, and all of the logic is in the process that could change independently from the i/o. Orthogonality is increased. You could further abstract input and output if you want. This could be done in Pig at some level using Macros to be fair. But not this clean and not this straightforward. This is pure beauty.</p>
</body>
</html>

  
  </article>
  
  </div>
  <div class="thefooter">
    <p>All Rights Reserved 
    <br><br>Copyright, <i>2019</i></p>
  </div> <!-- footer end -->
  <script src="/static/js/scramble.js"></script>
  <script>
    emailScramble = new scrambledString(document.getElementById('email'), 'emailScramble', 'dun@euuygbar.', [12, 9, 7, 6, 11, 13, 2, 8, 3, 1, 5, 4, 10]);
  </script>
    <script src="/static/js/logo.js"></script>
    <script src="https://d3js.org/d3.v3.min.js"></script>
    <script type="text/javascript">init();</script>
</body>
</html>