<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Distance Based Prioritization</title>

		<meta name="description" content="Distance Based Prioritization">
		<meta name="author" content="Buğra Akyıldız">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.css">
        <style>
            p {
              width: 720px;
            }

            h1, h2, h3 {
              font-weight: 300;
              text-rendering: optimizeLegibility;
            }

            h1 {
              font-size: 2.5em;
            }

            aside {
              font-size: small;
              position: absolute;
              right: 0;
              width: 180px;
            }

            aside p {
              width: auto;
            }

            p.cite, p.caption {
              color: #666;
            }

            p.caption {
              text-align: center;
              font-size: small;
              font-style: italic;
              width: auto;
            }
            rect { stroke: #000; fill: #fff; shape-rendering: crispEdges; }
            rect.on { fill: #fc0; }
            rect.off { fill: #0cf; }
            path { stroke: #000; fill: none; }
            .arc text {
              font: 10px sans-serif;
              text-anchor: middle;
            }
            .arc path {
              stroke: #fff;
            }
            
        </style>

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">
		<link href='http://fonts.googleapis.com/css?family=Lato:100,300,400' rel='stylesheet' type='text/css'>
		<!-- If the query includes 'print-pdf', include the PDF print sheet
		<link rel="stylesheet" href="css/print/p.css">-->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
                <section data-background="#1a1d20">
					<h2 style="line-height:1.5;"><strong>Distance Based Prioritization</strong></h2>
				</section>

                <section data-background="#37adb2">
                    <h3><strong> Raison D'être </strong></h3> 
                    <br>
                    <article> <strong>We believe people closer to you they are more likely to connect with you</strong></article>
                    <br>
                    <article> Solution: Prioritize based on distance. </article>
                    <br>
                    <strong> But... How ? </strong>
                </section>

                <section data-background="#45a4ec">
                    <h3> First Solution </h3>
                    <br>
                    <article> Include all of the people that are close to you, sample people that are far away to you.</article>
                    <br>
                    <h5 style="text-decoration: underline;"> Couple of problems </h5>
                    <br>
                    <ul>
                        <li> We are making the eligible list smaller. If you have few people, we are excluding even more people.</li>
                        <li> We do not really prioritize the closer people to you on their probability scores, but rather exclude people that are far away from you </li> 
                        <li> It is binary. We could be eliminating the <strong>bestfit</strong> due to distance. What is the purpose?</li>
                        <li> Sampling rate is magic number. </li>
                    </ul>
                </section>

                <section data-background="#45a4ec">
                    <h3> Second Solution</h3>
                    <br>
                    <article> Use <strong> distance </strong> as a divisor factor to compute <strong> match_probability </strong>
                        i.e; multiply it with (1/distance) </article>
                    <br>
                    <h5 style="text-decoration: underline;"> Couple of problems </h5>
                    <ul>
                        <li> Distance scale is very different than save probabilities; may affect <strong>match_probability</strong> very drastically </li> 
                        <li> Multiplication of distance will give a lot of weights to people very close to you; still could put the <strong>bestfit </strong> in tail </li>
                        <li> We may not want to make a distinction between 1 mile distance vs 2 mile distance; where this method decreases the 2 mile distance by half </li>
                    </ul>
                </section>

                <section data-background="#45a4ec">
                    <h2> <strong> Tier-Based Prioritization </strong></h2>
                </section>

                <section data-background="#45a4ec">
                    <h3> <strong> How? </strong></h3>
                    <br>
                    <ul>
                        <li> We divide people into tiers based on distance preference of the user </li>
                        <li> Penalize people distant from the user, do not penalize people close to user </li>
                        <li> There may not be a difference between people that are distant 5 miles vs 15 miles if user put 100 miles distance </li>
                        <li> But if user put 30 miles, 5 miles vs 15 miles could correspond to different match probabilities </li> 
                    </ul>
                </section>

                <section data-background="#3d5c96">
                    <ol>
                        <li> Look at the total number of people that are in max_distance range </li>
                        <li> Prioritize eligible people on the distance to the player: </li>
                            <ul> 
                                <li> If eligible person is below <strong> 30% </strong> of the <strong> max_distance</strong> range </li>
                                <ul> 
                                    <li> Keep the <strong> match_probability</strong> as it is </li>
                                </ul>

                                <li> If eligible person is within <strong>30%-70%</strong> of the <strong> max_distance</strong> range of the user </li>
                                <ul>
                                    <li> Subtract half standard deviation of the matching probabilities of all of the eligible people for eligible person’s <strong> match_probability</strong> </li>
                                </ul>
                                <li> If eligible person is between <strong> 70%</strong> of the <strong> max_distance</strong> to <strong> max_distance</strong> </li>
                                <ul>
                                    <li> Subtract full standard deviation of the matching probabilities of all of the eligible people for eligible person’s <strong> match_probability</strong> </li>
                                </ul>
                            </ul>
                    </ol>
                </section>

                <section data-background="#45a4ec">
                    <div id="chart"></div>
                </section>
                
                <section data-background="#55acee">
                    <h3><strong> Questions? </strong></h3>
                </section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>
        <script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script>

        <script>
            var width = 960,
                height = 600,
                radius = height / 2,
                firstTierRatio = .3,
                secondTierRatio = .7 - .3
                thirdTierRatio = 1 - firstTierRatio - secondTierRatio; 
            var firstTierEnd = firstTierRatio * radius,
                secondTierEnd = firstTierEnd + secondTierRatio * radius;
                thirdTierEnd = secondTierEnd + thirdTierRatio * radius;

            var color = d3.scale.ordinal()
                .range(["#60B2E5", "#71A2B6", "#7C8483"]);
            var thirdTierArc = d3.svg.arc()
                                 .outerRadius(thirdTierEnd)
                                 .innerRadius(secondTierEnd),
                secondTierArc = d3.svg.arc()
                                  .outerRadius(secondTierEnd)
                                  .innerRadius(firstTierEnd),
                firstTierArc = d3.svg.arc()
                                 .outerRadius(firstTierEnd)
                                 .innerRadius(0);
            var pie = d3.layout.pie()
                .sort(null)
                .value(function(d) { return +d.population; });
            var svg = d3.select("#chart").append("svg")
                .attr("width", width)
                .attr("height", height)
              .append("g")
                .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");
            var thirdTier = [{"age": "Subtract Full Standard Deviation",
                              "population": 100}],
                secondTier = [{"age": "Subtract Half Standard Deviation",
                               "population": 100}],
                firstTier = [{"age": "As it is",
                               "population": 100}];

            var g = svg.selectAll(".arc")
              .data(pie(firstTier))
            .enter().append("g")
              .attr("class", "arc");
            g.append("path")
              .attr("d", firstTierArc)
              .style("fill", function(d) { return color(d.data.age); });
            g.append("text")
              .attr("transform", function(d) { return "translate(" + firstTierArc.centroid(d) + ")"; })
              .attr("dy", ".35em")
              .text(function(d) { return d.data.age; });

            svg.selectAll(".arc")
              .data(pie(secondTier))
            .enter().append("g")
              .attr("class", "arc");
            g.append("path")
              .attr("d", secondTierArc)
              .style("fill", function(d) { return color(d.data.age); });
            g.append("text")
              .attr("transform", function(d) { return "translate(" + secondTierArc.centroid(d) + ")"; })
              .attr("dy", ".35em")
              .text(function(d) { return d.data.age; });

            svg.selectAll(".arc")
              .data(pie(thirdTier))
            .enter().append("g")
              .attr("class", "arc");
            g.append("path")
              .attr("d", thirdTierArc)
              .style("fill", function(d) { return color(d.data.age); });
            g.append("text")
              .attr("transform", function(d) { return "translate(" + thirdTierArc.centroid(d) + ")"; })
              .attr("dy", ".35em")
              .text(function(d) { return d.data.age; });
            function type(d) {
              d.population = +d.population;
              return d;
            }
        </script>


		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: false,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/zoom/linear/fade/none

                math: {
                    mathjax: 'http://cdn.mathjax.org/mathjax/latest/MathJax.js',
                    config: 'TeX-AMS_HTML-full'  // See http://docs.mathjax.org/en/latest/config-files.html
                },
				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
                    { src: 'plugin/math/math.js', async: true }, // Necessary for mathjax plugin

				]
			});

		</script>

	</body>
</html>
